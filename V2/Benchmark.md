# Benchmark

## v1 读写锁

### 特点

* 实现简单
* 多读不互斥

* 适合多读场景
* 避免读取中间数据

## v2 使用管道

### 特点

* 需要注意在不同协程读写
* 注意各种可能阻塞的情况
* 可以通过传递流动的数据进而实现通信
* 异步

## 为什么选择管道

因为之前有一个提示是说基于语言特性，那么提到go的话就是go协程和channel管道最有特点（Share memory by communicating, don't communicate by sharing memory.），并且一个计时器或者说一个流量统计的中间件，既然一周或者一个月才统计一次那么并不属于多读场景。且在刷新时面临一个读取，置零，存储这样一个数据流动的过程，那么可以使用channel来进行这些数据的传递。所以管道相对于读写锁我认为更加合适。（虽然实现起来稍微复杂一些）

## 设计模式

暂时给一个函数类型的管道，这样使读写更有序的执行，我认为在逻辑和实际执行上都是比较美观的，不过暂时只是将缓冲大小写死未解决缓冲大小与读写频率的关系